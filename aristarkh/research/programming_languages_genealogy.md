# Генеалогия языков программирования (рабочая карта)

## Зачем
Языки — формы мысли и дисциплины.
Мы изучаем не “синтаксис”, а:
- как язык заставляет мыслить,
- какие ошибки делает дорогими,
- как он помогает строить устойчивые системы.

---

## I. Узлы и “родная мысль” языка
### Lisp
- родная мысль: символы, метаязык, макросы
- дисциплина: “код как данные”
- полезно: протоколы, генераторы, DSL, форма мысли

### Smalltalk
- родная мысль: всё как объект, всё как сообщение
- дисциплина: среда и живой образ системы
- полезно: интерфейсы, композиция поведения

### Unix/C
- родная мысль: простые инструменты, композиция, текст
- дисциплина: ясность интерфейсов, минимализм зависимостей
- полезно: пайплайны, CLI, скрипты, сборка

### Prolog
- родная мысль: факты/правила/вывод
- дисциплина: “истина как запрос”
- полезно: knowledge vault, канон, объяснимые решения

### ML/Haskell → Clojure
- родная мысль: значения и трансформации
- дисциплина: функции, данные, композиция
- полезно: отчёты, обработка корпусов, чистые конвейеры

### Python
- родная мысль: практичность и читаемость
- дисциплина: “сделать работающий инструмент”
- полезно: оркестрация, пайплайны, прототипы, инструменты

### Dart/Flutter
- родная мысль: GUI как форма и дисциплина
- дисциплина: состояние/события/видимый результат
- полезно: приборы, панели управления проектом

---

## II. Метод Аристарха: как объяснять язык
1) Какая мысль у языка “родная”.
2) Какие ошибки он делает дорогими.
3) Как он дисциплинирует архитектора.
4) Какой артефакт мы строим на нём в relearning.
5) Как проверить результат (минимальный тест).

---

## III. Связь с проектом (пример)
- Python: “Research Toolkit v0” → CLI-инструменты → артефакты JSON/CSV
- Flutter: “Writer” → кнопки управления → лог, статус
- Prolog: “Vault” → ответы на вопросы канона → источник/дата/контекст

---

## IV. Примечание о моде
Мы не гонимся за трендами.
Мы строим навыки, которые переживают смену фреймворков:
- дисциплина интерфейсов
- протоколы
- тестируемость
- документация
